<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
        canvas {
            border: 10px solid #d3d3d3;
            background-color: #f1f1f1;
        }
    </style>
</head>
<body onload="startGame">
<script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/2.0.3/socket.io.js"></script>
    
<script>
    
    var player; //player controller ref
    var game;
        
    var socket = io();
        socket.emit("requestGame", "hi there.");
        socket.on("Start Game", function(msg)
        {
            startGame(msg);
        });
        socket.on("server_keypress", function(msg)
        {
          
            if(msg.gameId != game.id) return;
            
            onKeyChange(msg.userId, msg.key);
            
        });

function startGame(msg) 
{
        
    game = msg.game;
    player = game.players[msg.playerAssignment];
    gameArea.start();
    
}

var gameArea = {
    canvas : document.createElement("canvas"),
    start : function() 
    {
        this.canvas.width = 1080;
        this.canvas.height = 720;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);
        window.addEventListener('keydown', function (e) {
           if(!e.repeat)
           {
                onKeyChange(player.id, e);
                socket.emit("client_keypress", {
                    "gameId" : game.id,
                    "userId" : player.id,
                    "key" : {
                        "keyCode" : e.keyCode,
                        "type": e.type
                    }
                });
           }
        })
        window.addEventListener('keyup', function(e){
            onKeyChange(player.id, e);
            socket.emit("client_keypress", {
            "gameId" : game.id,
            "userId" : player.id,
            "key" : {
                   "keyCode" : e.keyCode,
                   "type": e.type
                }
          });
        })
    },
    clear : function() {
        this.context.clearRect(0,0, this.canvas.width, this.canvas.height);
    }
}

function onKeyChange(playerId, key)
{
    game.players[playerId].keys = (game.players[playerId].keys || []);
    game.players[playerId].keys[key.keyCode] = (key.type == 'keydown');
}

function updateGameArea() 
{
    gameArea.frameNo++;
    handleInputs();
    updateObjects();
    renderGameArea();
}

function handleInputs()
{
    for(let i = 0; i < game.players.length; i++)
    {
        handleInput(game.players[i]);
    }
}

function handleInput(controller)
{
        let dirX = 0;
        let dirY = 0;
        if(controller.keys)
        {
            if(controller.keys[37]){dirX = -1;}
            if(controller.keys[39]){dirX = 1;}
            if(controller.keys[38]){dirY = -1;}
            if(controller.keys[40]){dirY = 1;}
        }
        game.objects[controller.pawn_id].speedX = dirX;
        game.objects[controller.pawn_id].speedY = dirY;
}


function updateObjects()
{
    for(let i = 0; i < game.objects.length; i++)
    {
        updateObjectPosition(game.objects[i]);
    }
}

function updateObjectPosition(gameObject)
{
    gameObject.x += gameObject.speedX;
    gameObject.y += gameObject.speedY;
}

function renderGameArea() {
    gameArea.clear();
    for(let i = 0; i < game.objects.length; i++)
    {
        renderObject(gameArea.context, game.objects[i]);
        renderDebug(gameArea.context, game.objects[i]);
    }
}

function renderObject(context, gameObject)
{
    if (gameObject.type == "image") 
    {
        context.drawImage(gameObject.image, 
                gameObject.x, 
                gameObject.y,
                gameObject.width, gameObject.height);
    } 
    else 
    {
        context.fillStyle = gameObject.src;
        context.fillRect(gameObject.x, gameObject.y, gameObject.width, gameObject.height);
    }
}

function renderDebug(context, gameObject)
{
     context.fillStyle = "black";
     context.font = gameObject.width + " " + gameObject.height;
     context.fillText(gameObject.name, gameObject.x, gameObject.y+ (gameObject.height/2));      
}


//Object Types

function game(id, objects)
{
    this.id = id;
    this.players = [];
    this.objects = objects;
    this.state = "playing";
}


function controller(id, pawn_id)
{
    this.id = id;
    this.pawn_id = pawn_id;
    this.keys = [];
}

function component(id, name, width, height, src, x, y, type) {
    this.type = type;
    this.id = id;
    this.name = name;
    this.src = src;
    this.width = width;
    this.height = height;
    this.speedX = 0;
    this.speedY = 0;    
    this.x = x;
    this.y = y;    
}



</script>
   
    </body>
</html>